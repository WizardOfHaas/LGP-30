<html>
    <head>
        <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/xterm/3.14.5/xterm.min.css" integrity="sha512-iLYuqv+v/P4u9erpk+KM83Ioe/l7SEmr7wB6g+Kg1qmEit8EShDKnKtLHlv2QXUp7GGJhmqDI+1PhJYLTsfb8w==" crossorigin="anonymous" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/xterm/3.14.5/xterm.min.js" integrity="sha512-2PRgAav8Os8vLcOAh1gSaDoNLe1fAyq8/G3QSdyjFFD+OqNjLeHE/8q4+S4MEZgPsuo+itHopj+hJvqS8XUQ8A==" crossorigin="anonymous"></script>

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

        <style>
            table {
                font-family: monospace;
            }

            .ip {
                background-color: red;
            }

            textarea{
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <table>
                        <tr>
                            <td>C</td><td id="c"></td><td id="c-dec"></td>
                        </tr>
                        <tr>
                            <td>R</td><td id="r"></td><td id="r-dec"></td>
                        </tr>
                        <tr>
                            <td>A</td><td id="a"></td><td id="a-dec"></td><td id="a-ins"></td>
                        </tr>
                        <tr>
                            <td> </td><td>--------------|O--|T----|S----|</td>
                        </tr>
                    </table>
                </div>
            </div>

            <div class="row">
                <div class="col-md-12">
                    <button onclick="step()">STEP</button>
                    <button onclick="run()">RUN</button>
                </div>
            </div>

            <div class="row">
                <div class="col-md-6">
                    <textarea id="asm">
0000 u 1000 #Jump to entry
1000 p 0000
1001 b 1000
1002 a 2005 #Add up 1 to track
1003 y 1000 #Modify p

1004 b 2002 #Sets A to (2002)
1005 a 2001 #Adds (2001) to A
1006 h 2002 #Saves results in (2002)
1007 s 2003 #Subtracts 5 from A
1008 t 1000 #Tests, and jumps to top of loop
1009 z 0000 #Stop

2001 1 #Counter start
2003 63 #Counter stop
2004 a 2010 #Example fails... so my packing is wrong?
2005 128 #Track = 1. This is our incrementer
                    </textarea>
                </div>

                <div class="col-md-6">
                    <div id="term"></div>
                </div>
            </div>

            <div class="row">
                <div class="col-md-12">
                    <table id="mem"></table>
                </div>
            </div>
        </div>

        <script>
            //Setup terminal
            var term = new Terminal({cols: 40});
            term.open(document.getElementById("term"));

            var mem = Array(6363).fill(
                Array(31).fill(0)
            )

            const coolAddresses = []

            var regs = {
                c: Array(12).fill(0),   //Counter - Instruction Pointer
                    //C is encoded as TRACK|SECTOR
                    //  ...so I need to treat it... specially
                r: Array(31).fill(0),    //Instruction
                a: Array(31).fill(0)    //Accumulator
            }

            var running = false

            const chars = [ //Thanks SIMH!
                -1  , 'z', '0', ' ', '>', 'b', '1', '-',
                '<' , 'y', '2', '+', '|', 'r', '3', ';',
                '\r', 'i', '4', '/','\\', 'd', '5', '.',
                '\t', 'n', '6', ',', -1 , 'm', '7', 'v',
                '\'', 'p', '8', 'o', -1 , 'e', '9', 'x',
                -1  , 'u', 'f', -1 , -1 , 't', 'g', -1 ,
                -1  , 'h', 'j', -1 , -1 , 'c', 'k', -1 ,
                -1  , 'a', 'q', -1 , -1 , 's', 'w', 0  ,

                -1  , 'Z', ')', ' ', -1 , 'B', 'L', '_',
                -1  , 'Y', '*', '=', '|', 'R', '"', ':',
                '\r', 'I', '^', '?','\\', 'D', '%', ']',
                '\t', 'N', '$', '[', -1 , 'M', '~', 'V',
                '\'', 'P', '#', 'O', -1 , 'E', '(', 'X',
                -1  , 'U', 'F', -1 , -1 , 'T', 'G', -1 ,
                -1  , 'H', 'J', -1 , -1 , 'C', 'K', -1 ,
                -1  , 'A', 'Q', -1 , -1 , 'S', 'W', 0
            ]

            const orders = {
                "0001": { //Bring
                    name: "b",
                    eval: (order, track, sector) => {
                        const i = composeAddr(track, sector)
                        regs.a = mem[i]
                        return incAddr()
                    }
                },
                "1100": { //Hold and Store
                    name: "h",
                    eval: (order, track, sector) => {
                        const i = composeAddr(track, sector)
                        mem[i] = regs.a
                        return incAddr()
                    }
                },
                "1101": { //Clear and Store
                    name: "c",
                    eval: (order, track, sector) => {
                        const i = composeAddr(track, sector)
                        mem[i] = regs.a
                        regs.a = Array(31).fill(0)
                        return incAddr()
                    }
                },
                "0010": { //Store Address
                    //Moves address part of A into address part of ARG
                    name: "y",
                    eval: (order, track, sector) => {
                        const i = composeAddr(track, sector)

                        //a[18:28] -> mem[i][18:29]
                        const addr = regs.a.slice(18, 30)
                        console.log(addr)
                        mem[i] = insertArrayAt(mem[i], 18, addr)

                        return incAddr()
                    }
                },
                "1010": { //Unconditional transfer
                    name: "u",
                    eval: (order, track, sector) => {
                        const i = composeAddr(track, sector)

                        return track.concat(sector)
                    }
                },
                "0011": { //Return address
                    name: "r",
                    eval: (order, track, sector) => {
                        const i = composeAddr(track, sector)

                        const addr = incAddr()
                        mem[i] = insertArrayAt(mem[i], 19, addr)

                        return addr
                    }
                },
                "1011": { //Test
                    name: "t",
                    eval: (order, track, sector) => {
                        const i = composeAddr(track, sector)

                        if(regs.a[0] == 1){
                            return track.concat(sector)
                        }

                        return incAddr()
                    }
                },
                "0000": { //Stop
                    name: "z",
                    eval: () => {
                        running = false
                        return 0
                    }
                },
                "1000": { //Print
                    name: "p",
                    eval: (order, track, sector) => {
                        //I'll need to convert track -> character
                        //  ...I'll need a map
                        const c = chars[binToDec(track)]
                        print(c)
                        return incAddr()
                    }
                },
                "1110": { //Add
                    name: "a",
                    eval: (order, track, sector) => {
                        const i = composeAddr(track, sector)

                        regs.a = add(regs.a, mem[i])

                        return incAddr()
                    }
                },
                "1111": { //Subtract
                    name: "s",
                    eval: (order, track, sector) => {
                        const i = composeAddr(track, sector)

                        regs.a = sub(regs.a, mem[i])

                        return incAddr()
                    }
                },
            }

            const orderMap = {}

            Object.keys(orders).forEach((o) => {
                orderMap[orders[o].name] = o
            })

            /**
             * The loop is:
             *  Load mem[regs.c] -> regs.r
             *  Evaluate regs.r
             *  Determine next regs.c
             *  Back to top
            **/

            running = false
            $("#asm").val().split("\n").forEach(assembleLine)

            showMem()
            showRegs()

            async function run(){
                running = true
                while(running){
                    step()
                    await delay()
                }
            }

            //I can make this "realistic" using drum delay calculations
            async function delay(){
                return new Promise(resolve => setTimeout(resolve, 100))
            }

            //This is where I have to care about numeric representation
            function add(x, y){
                //Break refs
                const a = unpackNum(x)
                const b = unpackNum(y)

                const ret = packNum(a + b)

                return ret
            }

            function sub(x, y){
                const a = unpackNum(x)
                const b = unpackNum(y)

                const ret = packNum(a - b)

                return ret
            }

            function _sub(x, y){ //Switch to using unpack/pack
                //Break refs
                const a = x.slice()
                const b = y.slice()

                const aDec = binToDec(a)
                const bDec = binToDec(b)

                //console.log(aDec + " - " + bDec)

                const val = aDec - bDec

                const ret = decToBin(Math.abs(val), 31)

                if(val < 0){
                    ret[0] = 1 //Set sign bit
                }

                return ret
            }

            //Encode literal number
            function packNum(d){
                const w = decToBin(Math.abs(d), 31)

                if(d < 0){
                    w[0] = 1
                }
                
                return w
            }

            //Decode literal number
            function unpackNum(w){
                return (w[0] == 1 ? -1 : 1) * binToDec(w.slice(1))
            }

            function step(){
                const track = regs.c.slice(0, 6)
                const sector = regs.c.slice(6, 13)
                const addr = composeAddr(track, sector)

                const w = mem[addr]
                regs.c = runIns(w)
            }

            function print(c){
                console.log(c)
                term.write(c)
            }

            function showRegs(){
                $("#c").text(regs.c.join(""))
                $("#r").text(regs.r.join(""))
                $("#a").text(regs.a.join(""))

                $("#c-dec").text(decodeAddr())
                //$("#r-dec").text(binToDec(regs.r))
                $("#a-dec").text(unpackNum(regs.a))
                $("#a-ins").text(decode(regs.a))
            }

            //Write something to find relevant memory locations to display
            function showMem(){
                $("#mem").html("")
                const addr = decodeAddr()

                mem.forEach((m, i) => {
                    if(
                        coolAddresses.includes(i)
                    ){
                        $("#mem").append($(
                            "<tr" + (i == addr ? " class='ip'" : "") + "><td>" + i + "</td>" +
                            "<td>" + m.join("") + "</td>" +
                            "<td>(" + binToDec(m) + ")</td>" +
                            "<td>" + decode(m) + "</td>" +
                            "</tr>"
                        ))
                    }
                })
            }

            function decode(word){
                const order = word.slice(12, 16)
                const track = word.slice(18, 24)
                const sector = word.slice(24, 30)
                
                const orderId = order.join("")

                return orders[orderId].name + " " + binToDec(track) + ":" + binToDec(sector) //composeAddr(track, sector)
            }

            function runIns(word){
                regs.r = word //update the order register

                //Extract fields
                const order = word.slice(12, 16)
                const track = word.slice(18, 24)
                const sector = word.slice(24, 30)
                
                const orderId = order.join("")

                console.log(orders[orderId].name, order, track, sector)

                $("#r-dec").text(orders[orderId].name + ":" + composeAddr(track, sector))

                const ret = orders[orderId].eval(order, track, sector)
                showRegs()
                showMem()

                return ret
            }

            function binToDec(b){
                return parseInt(b.join(""), 2);
            }

            function decToBin(d, n){ //I'll need a hex equiv eventually
                const bits = d.toString(2).split("").map(Number)

                if(n == undefined){
                    return bits
                }

                return Array(n - bits.length).fill(0).concat(bits)
            }

            //I love JS sometimes...
            function composeAddr(track, sector){
                return parseInt(binToDec(track) + "" + (binToDec(sector) < 10 ? "0" + binToDec(sector) : binToDec(sector)))
            }

            function incAddr(){
                var track = binToDec(regs.c.slice(0, 6))
                var sector = binToDec(regs.c.slice(6, 13))


                sector++

                if(sector > 63){
                    sector = 0
                    track++
                }

                return decToBin(track, 6).concat(decToBin(sector, 6))
            }

            function decodeAddr(){
                const track = regs.c.slice(0, 6)
                const sector = regs.c.slice(6, 13)
                const addr = composeAddr(track, sector)
                return addr
            }

            function inc(word){
                var v = parseInt(word.join(""), 2)
                v++

                var result = v.toString(2).split("").map(parseInt)
                console.log(result)
                return Array(word.length - result.length).fill(0).concat(result)
            }

            function assembleLine(l){
                const parts = l.split(" ")

                //Get address
                const addr = parseInt(parts[0])
                coolAddresses.push(addr)

                //Test if this is an order
                if(Object.hasOwn(orderMap, parts[1])){
                    const order = orderMap[parts[1]].split("").map(Number)

                    mem[addr] = insertArrayAt(mem[addr], 12, order)

                    //Do we have an argument?
                    if(parts.length > 2 && !isNaN(Number(parts[2]))){
                        const track = decToBin(Number(parts[2].slice(0, 2)), 6)
                        const sector = decToBin(Number(parts[2].slice(2, 4)), 6)

                        coolAddresses.push(composeAddr(track, sector))

                        mem[addr] = insertArrayAt(mem[addr], 18, track.concat(sector))
                    }
                }else{
                    //Otherwise, this is a constant
                    mem[addr] = decToBin(Number(parts[1]), 31)
                }
            }

            function insertArrayAt(array, index, arrayToInsert) {
                var arr = array.slice() //Break the ref
                for(var i = index; i < index + arrayToInsert.length; i++){
                    arr[i] = arrayToInsert[i - index]
                }

                return arr
            }
        </script>
    </body>
</html>